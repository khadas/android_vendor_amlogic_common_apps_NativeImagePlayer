/* DO NOT EDIT THIS FILE - it is machine generated */
#include "ImageOperator.h"
#include "core_jni_helpers.h"
#include <jni/Bitmap.h>
#include <cutils/ashmem.h>
#include <media/stagefright/foundation/ADebug.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <amlogic/am_gralloc_ext.h>
#include <string>
#include <vector>
#include "android-base/parseint.h"
#include "android-base/properties.h"
using namespace android;
using namespace android::bitmap;
#define DEFAULT_WIDTH 1920
#define DEFAULT_HEIGHT 1080
#define GRALLOC1_VIDEO 1ULL << 17
#define PROPERTY "vendor.display-size"
sp<ANativeWindow> mNativeWindow;
ImageOperator *imageplayer;
JNIEnv *jnienv;
int fenceFd = -1;
int mRotate = 0;
int mFrameWidth = 0;
int mFrameHeight = 0;
static jfieldID mImagePlayer_ScreenWidth;
static jfieldID mImagePlayer_ScreenHeight;
static jfieldID mImagePlayer_VideoScale;
static std::string& StringTrim(std::string &str)
{
    if (str.empty()) {
        return str;
    }
    str.erase(0, str.find_first_not_of(" "));
    str.erase(str.find_last_not_of(" ") + 1);
    return str;
}
static int StringSplit(std::vector<std::string>& dst, const std::string& src, const std::string& separator)
{
    if (src.empty() || separator.empty())
        return 0;

    int nCount = 0;
    std::string temp;
    size_t pos = 0, offset = 0;

    while ((pos = src.find_first_of(separator, offset)) != std::string::npos)
    {
        temp = src.substr(offset, pos - offset);
        if (temp.length() > 0) {
            dst.push_back(StringTrim(temp));
            nCount ++;
        }
        offset = pos + 1;
    }

    temp = src.substr(offset, src.length() - offset);
    if (temp.length() > 0) {
        dst.push_back(StringTrim(temp));
        nCount ++;
    }

    return nCount;
}

static int render(int32_t width, int32_t height, void *data, size_t inLen);
status_t nativeWindowDisconnect(ANativeWindow *surface, const char *reason) {
    ALOGD("disconnecting from surface %p, reason %s", surface, reason);

    status_t err = native_window_api_disconnect(surface, NATIVE_WINDOW_API_MEDIA);
    ALOGE_IF(err != OK, "Failed to disconnect from surface %p, err %d", surface, err);

    return err;
}


status_t nativeWindowConnect(ANativeWindow *surface, const char *reason) {
    ALOGD("connecting to surface %p, reason %s", surface, reason);

    status_t err = native_window_api_connect(surface, NATIVE_WINDOW_API_MEDIA);
    ALOGE_IF(err != OK, "Failed to connect to surface %p, err %d", surface, err);

    return err;
}

static void* usesharemem(long size) {
    int fd = ashmem_create_region("swapbuffer", size);
    if (fd < 0) {
        return nullptr;
    }

    void* addr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    if (addr == MAP_FAILED) {
        close(fd);
        return nullptr;
    }

    if (ashmem_set_prot_region(fd, PROT_READ) < 0) {
        munmap(addr, size);
        close(fd);
        return nullptr;
    }
    return addr;
}

static int imageplayer_initialParam(JNIEnv *env, jobject entity) {
    ALOGE("imageplayer_initialParam");
    const std::string path(PROPERTY);
    const std::string v = android::base::GetProperty(path.c_str(), "1920x1080");
    if (!v.empty()) {
        std::vector<std::string> axis;
        int count=StringSplit(axis,v,"x");
        ALOGE("count= %d",count);
        if (count != 2) {
            mFrameWidth = DEFAULT_WIDTH;
            mFrameHeight = DEFAULT_HEIGHT;
        }else {
            ALOGE("read axis %s %s",axis[0].c_str(),axis[1].c_str());
            mFrameWidth = atoi(axis[0].c_str());
            mFrameHeight = atoi(axis[1].c_str());
        }
        ALOGE("read axis %s %d %d",v.c_str(),mFrameWidth,mFrameHeight);

    }

    jclass imageplayer_class = FindClassOrDie(env,"com/droidlogic/imageplayer/ImagePlayer");
    mImagePlayer_ScreenWidth = GetFieldIDOrDie(env,imageplayer_class,"mScreenWidth","I");
    mImagePlayer_ScreenHeight = GetFieldIDOrDie(env,imageplayer_class,"mScreenHeight","I");
    mImagePlayer_VideoScale = GetFieldIDOrDie(env,imageplayer_class,"mScaleVideo","F");
    int lastHeight = env->GetIntField(entity,mImagePlayer_ScreenHeight);
    int lastWidth = env->GetIntField(entity,mImagePlayer_ScreenWidth);
    ALOGE("last solution %d x%d",lastWidth,lastHeight);
    bool ret = -1;
    if (lastHeight > 0 && lastWidth > 0 && (lastHeight != mFrameHeight || lastWidth != mFrameWidth)) {
        ret = 0;
    }
    env->SetIntField(entity, mImagePlayer_ScreenWidth, mFrameWidth);
    env->SetIntField(entity, mImagePlayer_ScreenHeight,mFrameHeight);
    env->SetFloatField(entity, mImagePlayer_VideoScale,(1.0*mFrameWidth/DEFAULT_WIDTH));
    ALOGE("after initial param");
    return ret;
}
static void  imageplayer_nativeInitSurface(JNIEnv *env, jclass clz, jobject jsurface){
    sp<IGraphicBufferProducer> new_st = NULL;
    jnienv = env;
    if (jsurface) {
        sp<Surface> surface(android_view_Surface_getSurface(env, jsurface));
        if (surface != NULL) {
            new_st = surface->getIGraphicBufferProducer();

            if (new_st == NULL) {
                jniThrowException(env, "java/lang/IllegalArgumentException",
                                  "The surface does not have a binding SurfaceTexture!");
                return;
            }
        } else {
            jniThrowException(env, "java/lang/IllegalArgumentException",
                              "The surface has been released");
            return;
        }
    }

    if (new_st != NULL) {
        mNativeWindow = new Surface(new_st,/*controlledByApp*/false);
        ALOGI("before connect");
        native_window_api_connect(mNativeWindow.get(),
                       NATIVE_WINDOW_API_MEDIA);
        ALOGI("set native window overlay %0x",GRALLOC1_PRODUCER_USAGE_CAMERA);

        //CHECK_EQ(0,native_window_set_usage(mNativeWindow.get(), am_gralloc_get_video_decoder_full_buffer_usage()));
        CHECK_EQ(0,native_window_set_usage(mNativeWindow.get(), GRALLOC1_PRODUCER_USAGE_CAMERA));
        native_window_set_scaling_mode(mNativeWindow.get(),NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
        native_window_set_buffers_format(mNativeWindow.get(), HAL_PIXEL_FORMAT_YCrCb_420_SP);

        imageplayer = new ImageOperator(env);
        imageplayer->setSurfaceSize(mFrameWidth,mFrameHeight);
    }
  }


static int imageplayer_rotate(JNIEnv *env, jclass clz,jfloat ori) {
    ALOGE("imageplayer_rotate %f",ori);
    SkBitmap rotateBitmap;
    imageplayer->setRotate(ori,rotateBitmap);
    ALOGE("after rotate %d %d",rotateBitmap.width(),rotateBitmap.height());
    uint8_t* pixelBuffer = (uint8_t*)rotateBitmap.getPixels();

   // android_native_rect_t standard = {0,0,rotateBitmap.width(),rotateBitmap.height()};
   // CHECK_EQ(OK, native_window_set_crop(mNativeWindow.get(), &standard));
   // CHECK_EQ(OK, native_window_set_scaling_mode(mNativeWindow.get(),NATIVE_WINDOW_SCALING_MODE_NO_SCALE_CROP));
    render(rotateBitmap.width(),rotateBitmap.height(),pixelBuffer,rotateBitmap.width()*rotateBitmap.height());
    return 0;
}
static int render(int32_t width, int32_t height, void *data, size_t inLen) {
    status_t err = NO_ERROR;
    int ret = 0;
    int frame_width = ((width + 1) & ~1);
    int frame_height =((height + 1) & ~1);
    ALOGE("render for frame size (%d x %d)-->(%d x %d)",width,height,frame_width,frame_height);
    ANativeWindowBuffer *buf;
    native_window_set_buffers_dimensions(mNativeWindow.get(), frame_width, frame_height);
    status_t res =  mNativeWindow->dequeueBuffer(mNativeWindow.get(),&buf,&fenceFd);
    if (res != OK) {
        ALOGE("%s: Dequeue buffer failed: %s (%d)", __FUNCTION__, strerror(-res), res);
        switch (res) {
            case NO_INIT:
                jniThrowException(jnienv, "java/lang/IllegalStateException",
                    "Surface has been abandoned");
                break;
            default:
                jniThrowRuntimeException(jnienv, "dequeue buffer failed");
        }
        return ret;
    }
    ALOGE("-->buf %d %d  %d %d %p",buf->format,buf->stride,buf->width, buf->height, buf);

    GraphicBufferMapper &mapper = GraphicBufferMapper::get();
    Rect bounds(frame_width,frame_height);
    uint8_t* img = NULL;

    err =  mapper.lock(buf->handle,GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_NEVER,bounds,(void**)(&img));
    if (err != NO_ERROR) return err;
    if (ret != OK) {
        ALOGE("%s: Error trying to lock output buffer fence: %s (%d)", __FUNCTION__,
                strerror(-ret), ret);
        return ret;
    }
    memset(img, 128, buf->height * buf->stride*3/2);
    memset(img, 0 , buf->stride *  buf->height);
    uint8_t* yPlane = img;
    uint8_t* uPlane = img + buf->stride*buf->height;
    uint8_t* vPlane = uPlane + 1;
    size_t chromaStep = 2;
    size_t yStride = buf->stride;
    size_t chromaStride =  buf->stride;
    uint8_t* pixelBuffer = (uint8_t*)data;
    imageplayer->rgbToYuv420(pixelBuffer, width, height, yPlane,
                    uPlane, vPlane, chromaStep, yStride, chromaStride);
    mapper.unlock(buf->handle);
    mNativeWindow->queueBuffer(mNativeWindow.get(), buf,  -1);
    return 0;
}
static jint nativeShow(JNIEnv *env, jclass clz, jlong jbitmap){
    ALOGE("nativeShow %d %d %d",(mNativeWindow.get() == NULL),(imageplayer == NULL),(jbitmap <=0));
    if (mNativeWindow.get() == NULL || imageplayer == NULL || jbitmap <=0 ) {
        return -1;
    }

    SkBitmap skbitmap;
    imageplayer->init(jbitmap,0,true) ;
    Bitmap* bitmap = reinterpret_cast<Bitmap*>(jbitmap);

    bitmap->getSkBitmap(&skbitmap);
    ALOGE("skColorType %d %d %d",bitmap->colorType(),bitmap->width(),bitmap->height());
    uint8_t* pixelBuffer = (uint8_t*)skbitmap.getPixels();

    return render(bitmap->width(),bitmap->height(),pixelBuffer,bitmap->width()*bitmap->height());

  }

static jint imageplayer_rotateCrop(JNIEnv* env, jclass clz,jfloat ori, jint width, jint height) {
    ALOGE("crop %f %d %d",ori,width,height);
    SkBitmap bmp;
    if (((int)ori) %360 == 0)
        imageplayer->getSelf(bmp);
    else
        imageplayer->setRotate(ori,bmp);
    ALOGE("before crop after rotate %d %d[mFrame%dx%d]",bmp.width(),bmp.height(),mFrameWidth,mFrameHeight);

    if (bmp.height() > mFrameHeight || bmp.width() > mFrameWidth) {
        ALOGE("!!!!!!!!!!!!!!!!!!!!!!!!!!!");
        int hy = bmp.height()-height > 0 ? bmp.height()-height:height-bmp.height();
        int wx = bmp.width()-width > 0 ? bmp.width()-width:width - bmp.width();
        android_native_rect_t standard = {wx/2,hy/2,(bmp.width()+width)/2,(bmp.height()+height)/2};
        ALOGE("----crop [%d %d %d %d]",wx/2,hy/2,(bmp.width()+width)/2,(bmp.height()+height)/2);
        CHECK_EQ(OK, native_window_set_crop(mNativeWindow.get(), &standard));
    } else {
        int x = bmp.width()<width? 0:(bmp.width()-width)/2;
        int y = bmp.height()<height? 0:(bmp.height()-height)/2;
        android_native_rect_t standard = {x,y,x+width,y+height};
        ALOGE("---->crop [%d %d %d %d]",x,y,x+width,y+height);
        CHECK_EQ(OK, native_window_set_crop(mNativeWindow.get(), &standard));
    }
    uint8_t* pixelBuffer = (uint8_t*)bmp.getPixels();
    return render(bmp.width(),bmp.height(),pixelBuffer,bmp.width()*bmp.height());
}

  static jint imageplayer_nativeScale(JNIEnv *env, jclass clz,jfloat sx,jfloat sy,jlong jbitmap) {
    int ret = 0;
    ALOGE("nativeScale %f %f",sx,sy);
    if (sx > 1.0) {
        android_native_rect_t standard = {0,0,static_cast<int>(mFrameWidth/sx),static_cast<int>(mFrameHeight/sy)};
        CHECK_EQ(OK, native_window_set_crop(mNativeWindow.get(), &standard));
    }else {
        CHECK_EQ(OK, native_window_set_scaling_mode(mNativeWindow.get(),NATIVE_WINDOW_SCALING_MODE_FREEZE));
       // android_native_rect_t standard = {0,0,static_cast<int>(mFrameWidth*sx),static_cast<int>(mFrameHeight*sy)};
        //CHECK_EQ(OK, native_window_set_crop(mNativeWindow.get(), &standard));

    }
    SkBitmap skbitmap;
    Bitmap* bitmap = reinterpret_cast<Bitmap*>(jbitmap);

    bitmap->getSkBitmap(&skbitmap);
    ALOGE("=====skColorType %d %d %d",bitmap->colorType(),bitmap->width(),bitmap->height());
    uint8_t* pixelBuffer = (uint8_t*)skbitmap.getPixels();

    return render(bitmap->width(),bitmap->height(),pixelBuffer,bitmap->width()*bitmap->height());
}
static void imageplayer_release(JNIEnv *env, jclass clz){
    //CHECK_EQ(OK,native_window_api_disconnect(mNativeWindow.get(), NATIVE_WINDOW_API_EGL));
}
static const JNINativeMethod gImagePlayerMethod[] = {
    {"initParam",           "()I",     (void*)imageplayer_initialParam},
    {"nativeInitSurface",                "(Landroid/view/Surface;)V",          (void*)imageplayer_nativeInitSurface },
    {"nativeShow",                "(J)I",                               (void*)nativeShow },
    {"nativeScale",               "(FFJ)I",                             (void*)imageplayer_nativeScale},
    {"nativeRotate",              "(F)I",                               (void*)imageplayer_rotate},
    {"nativeRotateCrop",                "(FII)I",                       (void*)imageplayer_rotateCrop},
    {"nativeRelease",            "()V",                                (void*)imageplayer_release},

};

int register_com_droidlogic_imageplayer_ImagePlayer(JNIEnv* env) {
    return android::RegisterMethodsOrDie(env, "com/droidlogic/imageplayer/ImagePlayer", gImagePlayerMethod,
                                         NELEM(gImagePlayerMethod));
}
